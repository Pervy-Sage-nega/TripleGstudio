üìå accounts/models.py
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
from datetime import timedelta
import random

class OneTimePassword(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    code = models.CharField(max_length=6)
    created_at = models.DateTimeField(auto_now_add=True)

    def is_expired(self):
        return timezone.now() > self.created_at + timedelta(minutes=10)

    @staticmethod
    def generate_code():
        return str(random.randint(100000, 999999))

üìå accounts/forms.py
from django import forms
from django.contrib.auth.models import User

class RegisterForm(forms.ModelForm):
    password = forms.CharField(widget=forms.PasswordInput)
    class Meta:
        model = User
        fields = ['username', 'email', 'password']

class OTPForm(forms.Form):
    otp = forms.CharField(max_length=6, required=True, label="Enter OTP")

üìå accounts/views.py
from django.shortcuts import render, redirect
from django.contrib import messages
from django.core.mail import send_mail
from django.contrib.auth.models import User
from django.conf import settings

from .forms import RegisterForm, OTPForm
from .models import OneTimePassword

# Register View
def register(request):
    if request.method == "POST":
        form = RegisterForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.set_password(form.cleaned_data['password'])
            user.is_active = False
            user.save()

            # Generate OTP
            code = OneTimePassword.generate_code()
            OneTimePassword.objects.update_or_create(user=user, defaults={"code": code})

            # Send OTP via email
            send_mail(
                "Verify your Triple G account",
                f"Your OTP code is {code}. It will expire in 10 minutes.",
                settings.DEFAULT_FROM_EMAIL,
                [user.email],
                fail_silently=False,
            )

            messages.info(request, "Account created! Please verify with the OTP sent to your email.")
            request.session['pending_user_id'] = user.id
            return redirect("verify_otp")
    else:
        form = RegisterForm()
    return render(request, "accounts/register.html", {"form": form})


# OTP Verification View
def verify_otp(request):
    user_id = request.session.get('pending_user_id')
    if not user_id:
        return redirect("register")

    user = User.objects.get(id=user_id)
    otp_obj = OneTimePassword.objects.filter(user=user).first()

    if request.method == "POST":
        form = OTPForm(request.POST)
        if form.is_valid():
            code = form.cleaned_data['otp']
            if otp_obj and otp_obj.code == code and not otp_obj.is_expired():
                user.is_active = True
                user.save()
                otp_obj.delete()
                messages.success(request, "Account verified! You can now log in.")
                return redirect("login")
            else:
                messages.error(request, "Invalid or expired OTP.")
    else:
        form = OTPForm()
    return render(request, "accounts/verify_otp.html", {"form": form, "email": user.email})


# Resend OTP View
def resend_otp(request):
    user_id = request.session.get('pending_user_id')
    if not user_id:
        return redirect("register")

    user = User.objects.get(id=user_id)
    code = OneTimePassword.generate_code()
    OneTimePassword.objects.update_or_create(user=user, defaults={"code": code})

    send_mail(
        "Resend OTP - Triple G account",
        f"Your new OTP code is {code}. It will expire in 10 minutes.",
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        fail_silently=False,
    )

    messages.success(request, "A new OTP has been sent to your email.")
    return redirect("verify_otp")

üìå accounts/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("register/", views.register, name="register"),
    path("verify-otp/", views.verify_otp, name="verify_otp"),
    path("resend-otp/", views.resend_otp, name="resend_otp"),
]

üìå templates/accounts/register.html
<h2>Create Account</h2>
<form method="POST">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">Register</button>
</form>

üìå templates/accounts/verify_otp.html
<h2>Verify Account</h2>
<p>We sent an OTP to your email: {{ email }}</p>
<form method="POST">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">Verify</button>
</form>

<p>Didn't receive the code? 
   <a href="{% url 'resend_otp' %}">Resend OTP</a>
</p>

üìå settings.py (Email setup for OTP)

Add this for email sending (use Gmail SMTP or service like SendGrid, Mailgun):

# Example: Gmail SMTP
EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
EMAIL_HOST = "smtp.gmail.com"
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = "your-email@gmail.com"
EMAIL_HOST_PASSWORD = "your-app-password"  # Use app password, not your raw Gmail password
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER

üîí Security Checklist

OTP expires in 10 minutes.

OTP is deleted once used.

Prevent brute force ‚Üí consider libraries like django-axes.

Always deploy over HTTPS.

Emails should use App Passwords / secure SMTP.

‚úÖ This gives you:

Register ‚Üí inactive user created

OTP emailed

Verify OTP ‚Üí activate user

Resend OTP option













üìå Descriptive Plan for Secure Registration with OTP Verification
1. User Registration Flow

A new user fills out the registration form (username, email, password).

When the form is submitted:

The password is hashed using Django‚Äôs set_password() method.

The user account is created but marked as inactive (user.is_active = False).

An OTP code is generated (6 digits, random).

The OTP is stored in the OneTimePassword model linked to the user.

An email is sent to the user with the OTP code and a message that it expires in 10 minutes.

The system saves the user‚Äôs ID in the session (request.session['pending_user_id']) so the verification step knows which user is pending activation.

2. OTP Verification Flow

The user is redirected to the OTP verification page.

They enter the OTP code into the form.

When submitted:

The system checks:

If the OTP exists for the user.

If the code matches.

If the OTP is not expired (older than 10 minutes ‚Üí rejected).

If valid:

The user account is activated (user.is_active = True).

The OTP record is deleted from the database.

The user receives a success message and is redirected to the login page.

If invalid or expired:

An error message is shown (Invalid or expired OTP).

3. Resend OTP Flow

If the user doesn‚Äôt receive the OTP or it expires:

They click ‚ÄúResend OTP‚Äù on the verification page.

A new 6-digit OTP is generated and updated in the database.

A new email is sent with the updated code.

The old code is automatically replaced.

The user is redirected back to the verification page with a success message.

4. Security Features

üîê OTP Expiry ‚Üí Each OTP is valid only for 10 minutes.

üîê OTP Deletion ‚Üí Once successfully used, the OTP record is deleted.

üîê Inactive Until Verified ‚Üí Users cannot log in until they successfully verify with OTP.

üîê Brute Force Protection ‚Üí Add optional libraries like:

django-axes (blocks repeated failed login attempts).

Rate limiting OTP verification attempts.

üîê Secure Email Delivery ‚Üí

Use Gmail App Passwords or services like SendGrid/Mailgun.

Never store plain email passwords in the code.

üîê Transport Security ‚Üí Always deploy with HTTPS (TLS) so credentials/OTPs aren‚Äôt intercepted.

5. User Experience (UX)

‚úÖ Clear messages guide the user through registration and verification.

‚úÖ Resend OTP option prevents frustration if an email is delayed.

‚úÖ Success message after activation confirms account is ready.

‚úÖ Minimal fields in the register form make it simple for users.

6. Future Improvements (Optional Enhancements)

üì± Add SMS OTP using services like Twilio for better reach.

üîÑ Add Backup Verification (e.g., recovery email, secret questions).

üìä Track verification attempts to detect unusual activity.

üïí Allow users to request OTP only after a cooldown (e.g., 30s ‚Äì 1min) to prevent spamming.

üõ° Use reCAPTCHA on registration to reduce bot signups.

‚úÖ Summary:
Your system will:

Register users as inactive.

Send OTP to email.

Require OTP verification before login.

Allow resending of OTP if needed.

Protect against brute force & ensure secure delivery.

---

### üöÄ Enhancements & Best Practices (Recommended)

**Brute Force Protection:**
- Implement libraries like `django-axes` to block repeated failed login or OTP attempts.
- Consider rate limiting OTP verification and resend attempts.

**Rate Limiting for OTP Resend:**
- Add a cooldown (e.g., 30‚Äì60 seconds) before a user can request another OTP.

**Logging & Monitoring:**
- Log failed OTP and login attempts for auditing and possible lockout after repeated failures.

**Email Improvements:**
- Use Django‚Äôs templated emails for branded, user-friendly OTP messages.
- Consider adding a warning if an OTP is about to expire.

**Testing:**
- Add automated tests for registration, OTP expiry, resend, and verification flows.

**User Feedback:**
- Alert users if they are close to OTP expiry or have requested too many resends.

**SMS Option (Optional):**
- Add SMS OTP using services like Twilio for broader reach.

**Backup Verification:**
- Consider supporting backup email or secret questions for account recovery.

**Cool-down for OTP Requests:**
- Prevent spamming by enforcing a delay between OTP requests.

**reCAPTCHA:**
- Add reCAPTCHA to registration to reduce bot signups.

**Transport Security:**
- Always deploy with HTTPS (TLS) to protect credentials and OTPs in transit.

**Summary:**
These enhancements will make your authentication system even more robust, user-friendly, and secure for production environments.


---

## üìå Adminside Authentication Plan (`accounts/templates/admin/`)

### 1. **Admin Registration Flow**
- **User fills out registration form** with first name, last name, email, password, and confirms password.
- **Terms and Privacy Policy** agreement required.
- **Password strength meter** and validation.
- **Form validation** for all fields (frontend + backend).
- **Upon submission:**
  - Admin account is created as **inactive** (pending approval by superadmin or system).
  - Email confirmation is sent (optional: OTP or activation link).
  - Success modal informs user that registration is pending approval.

### 2. **Admin Login Flow**
- **User fills out login form** with email and password.
- **Remember me** option for persistent sessions.
- **Password visibility toggle** and forgot password link.
- **Social logins** (Google, Microsoft) as future enhancement (UI present).
- **Error modal** for invalid credentials.
- **Only active admin users can log in** (inactive = pending approval or suspended).

### 3. **Email/OTP Verification (Optional/Recommended)**
- **After registration**, send an OTP or activation link to admin's email.
- **OTP/activation link** expires after a set time (e.g., 10 minutes).
- **Verification page** for OTP input or link click.
- **Upon successful verification:**
  - Admin account is marked as verified and awaits approval (if required).
  - OTP is deleted from the database.
- **Resend OTP** functionality with cooldown to prevent abuse.

### 4. **Admin Approval (Manual or Automated)**
- **Superadmin reviews pending admin registrations**.
- **Approve/deny** actions available in the admin dashboard.
- **Email notification** sent to admin upon approval or denial.
- **Only approved and verified admins can access admin dashboard.**

### 5. **Security Features**
- **Password hashing** with Django's built-in mechanisms.
- **CSRF protection** on all forms.
- **Rate limiting** for login and OTP verification attempts.
- **Brute force protection** (recommend `django-axes` or similar).
- **All sensitive actions require HTTPS**.
- **Audit logging** for all admin authentication events (login, logout, failed attempts, registration).

### 6. **UI/UX Features**
- **Professional, branded design** consistent with Triple G BuildHub.
- **Responsive layout** for desktop and tablet.
- **Accessible forms** with clear labels, error messages, and ARIA attributes.
- **Toast/modal notifications** for feedback (success, error, info).
- **Password strength indicator** and visibility toggle.
- **Clear guidance** for next steps after registration and login.

### 7. **Database Structure**
- **Admin users** are stored in the same `auth_user` table, distinguished by `is_staff` and/or `is_superuser`.
- **Profile extension** (optional): Add admin-specific fields in a related `Profile` or `AdminProfile` model.
- **OTP table** for email verification if used.

### 8. **URLs & Views**
- `/accounts/admin/login/` ‚Äî Login page
- `/accounts/admin/register/` ‚Äî Registration page
- `/accounts/admin/verify-otp/` ‚Äî OTP/email verification
- `/accounts/admin/logout/` ‚Äî Logout
- **Views**: Use Django CBVs or FBVs with @transaction.atomic, CSRF, and security best practices.

### 9. **Email Configuration**
- **SMTP settings** for sending OTPs/confirmation emails.
- **Templated emails** for branding and clarity.
- **App password or secure credentials** for email backend.

### 10. **Testing & Quality Assurance**
- **Automated tests** for registration, login, OTP, approval, and edge cases.
- **Manual testing** for all flows and error scenarios.
- **Security testing** (rate limiting, brute force, session management).

### 11. **Future Enhancements**
- **Multi-factor authentication** (MFA) for admin logins.
- **Admin activity logs** and dashboards.
- **Role-based permissions** (superadmin, manager, staff).
- **Single Sign-On (SSO)** integration for enterprise environments.
- **reCAPTCHA** on registration and login to prevent bots.
- **SMS-based OTP** as an additional option.

---

**Summary:**  
This plan ensures the adminside authentication is robust, secure, and user-friendly, matching the standards set for your client-side system. It is ready for production with scalability
 and future enhancements in mind.